<div class="slide nocode">
  <h2>Introducing ATS to AVR Devices</h2>
  
  <p>If you've gotten a bit of experience with ATS you might like to try
    it out in embedded development. Since ATS compiles directly to C, it's 
    a prime candidate for writing verified device drivers and firmware. In 
    this tour, we cover some simple examples with writing firmware targeted
    at 8-bit AVR microcontrollers.
  </p>

  <h3>Arduino</h3>
  <p>
    Arduino is a hobbyist platform that enables rapid prototyping of 
    embedded projects. It provides extensible hardware around AVR devices 
    and an easy to use development environment that uses the Wiring 
    programming language. Users can build shield devices to extend the 
    bare-bones Arduino boards and upload sketches through a Serial over 
    USB interface to a boot-loader on the AVR chip which writes the 
    sketch to the flash memory in the micro-controller. This method is 
    efficient, convenient, and drastically lowers the learning barrier
    to building devices that interact with the real world. At the same 
    time, it does introduce overhead by working with an environment 
    similar to C++ and has the obvious dependency that sketches are
    targeted towards Arduino PCBs. In short, it's fun, useful, and 
    powerful, but you probably won't use them for most commercial
    applications.
  </p>
  
  <h3>Introducing ATS</h3>
  <p>
    The problem we wish to solve by introducing ATS to this environment
    is how to provide reasonable guarantees to program correctness without
    introducing significant overhead. In addition, we want to provide an 
    environment for all AVR devices that allows programmers to add more
    static verification to their drivers; ATS should be viewed as a
    reliable front-end for C programming.
  </p>

  <p>
    The tutorial does not talk about things at the high level you find 
    in Arduino sketches, but instead at the level you'd find working 
    with the avr-libc library. In this way, we use the type system of 
    ATS to reason about various states of the MCU, as well as important
    parts of our program such as safe memory accesses.
  </p>

  <h3>Requirements</h3>
  <p>
    Currently, we only target the AVR Atmega328p chip and assume you have
    an Arduino board to work with. In addition, you'll need to have an ISP
    programmer to flash the hex files generated by the online compiler or 
    perhaps a boot-loader that can do the trick. To download the hex file
    for your code, just click "Download Hex" from the compiler options
    from the menu bar. If you really get lost in the weeds, you can 
    always just reset your code to the canned examples we provide.
  </p>

  <p>
    Also, you'll need a few resistors and LEDs if you want to flash some
    lights, but otherwise we'll mostly just use the serial interface.
  </p>
</div>

<div class="slide">
  <h2>Hello Blinkey</h2>
  <p>
    The first program we always try out is, of course, Hello World. In the
    world of 8-bit microcontrollers, this is actually a fairly involved 
    application, so let's just try to flash an LED on and off.
  </p>
  
  <p>
    What does that mean from the perspective of our microcontroller? To turn 
    an LED on, we need to obviously send a current across it. The AVR only
    knows how to set the voltage at a pin to "Logic High", at 5 Volts, or 
    "Logic Low", which just grounds the pin. Pins are organized into ports
    in the MCU, and ports are represented as 8-bit registers that are mapped
    into the MCU's memory. 
  </p>
  <div>
staload "SATS/io.sats"
staload "SATS/delay.sats"

implement main () = loop() where {
	val () = setbits(DDRB, DDB3)
    fun loop () : void = let
        val () = flipbits(PORTB, PORTB3)
        val () = delay_ms(500.0)
    in loop() end
}
  </div>
</div>

<div class="slide">
  <h2>Variable Voltage with PWM</h2>
  <p>
  </p>

  <div>
  </div>
</div>
