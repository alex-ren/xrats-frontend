{"input":"(*\n    ** Copyright (C) 2012 Hongwei Xi, Boston University\n    ** An Example of the ATS2 Typechecker at work with Fibonacci Numbers\n    *)\n    staload \"doc/EXAMPLE/ARITH/basics.sats\"\n    staload \"doc/EXAMPLE/ARITH/fibonacci.sats\"\n    \n    implement\n    fib_istot {n} () = let\n    //s\n    prfun\n    istot {n:nat} .<n>.\n      (): [r:nat] FIB (n, r) =\n      sif n == 0 then FIBbas1 ()\n      else sif n == 1 then FIBbas2 ()\n      else FIBind (\n        istot {n-2} (), istot {n-1} ()\n      ) // end of [sif]\n    // end of [istot]\n    //\n    in\n      istot {n} ()\n    end // end of [fib_istot]\n    \n    (* ****** ****** *)\n    \n    primplement\n    fib_isfun (pf1, pf2) = let\n    //\n    prfun isfun\n      {n:nat}{r1,r2:int} .<n>. (\n      pf1: FIB (n, r1), pf2: FIB (n, r2)\n    ) : [r1==r2] void =\n      case+ (pf1, pf2) of\n      | (FIBbas1 (), FIBbas1 ()) => ()\n      | (FIBbas2 (), FIBbas2 ()) => ()\n      | (FIBind (pf11, pf12),\n         FIBind (pf21, pf22)) => let\n          prval () = isfun (pf11, pf21)\n          prval () = isfun (pf12, pf22)\n        in\n          (*nothing*)\n        end // end of [FIBind, FIBind]\n    // end of [isfun]\n    //\n    in\n      isfun (pf1, pf2)\n    end // end of [fib_isfun]\n    \n    primplement\n    fib_isfun2 (pf1, pf2) = let\n      prval () = fib_isfun (pf1, pf2) in inteq_make ()\n    end // end of [fib_isfun2]\n    \n    (* ****** ****** *)\n    //\n    // HX-2012-03:\n    // fib(m+n+1)=fib(m)*fib(n)+fib(m+1)*fib(n+1)\n    //\n    primplement\n    fibeq1\n      (pf1, pf2, pf3, pf4) = let\n    //\n    prfun\n    lemma {m,n:nat}\n      {r1,r2,r3,r4:int} .<m>. (\n      pf1: FIB (m, r1) // r1 = fib(m)\n    , pf2: FIB (n, r2) // r2 = fib(n)\n    , pf3: FIB (m+1, r3) // r3 = fib(m+1)\n    , pf4: FIB (n+1, r4) // r4 = fib(n+1)\n    ) : FIB (m+n+1, r1*r2+r3*r4) = let\n    //\n    // HX: it is by standard mathematical induction\n    //\n    in\n    //\n    sif m > 0 then let\n      prval FIBind (pf30, pf31) = pf3\n      prval INTEQ () = fib_isfun2 (pf1, pf31)\n    in\n      lemma {m-1,n+1}\n        (pf30, pf4, pf31, FIBind (pf2, pf4))\n      // end of [lemma]\n    end else let\n      prval FIBbas1 () = pf1; prval FIBbas2 () = pf3 in pf4\n    end // end of [sif]\n    //\n    end // end of [lemma]\n    //\n    in\n    //\n    lemma (pf1, pf2, pf3, pf4)\n    //\n    end // end of [fibeq1]\n    \n    (* ****** ****** *)\n    //\n    // HX-2012-03:\n    // fib(n)*fib(n+2) + (-1)^n = (fib(n+1))^2\n    //\n    primplement\n    fibeq2 (\n      pf0, pf1, pf2, pf3\n    ) = let\n    //\n    prfun\n    fibeq2\n      {n:nat}{i:int}\n      {f0,f1,f2:int} .<n>. (\n      pf0: FIB (n, f0)\n    , pf1: FIB (n+1, f1)\n    , pf2: FIB (n+2, f2)\n    , pf3: SGN (n, i)\n    ) : [\n      f0*f2 + i == f1*f1\n    ] void =\n      sif n > 0 then let\n        prval FIBind (pf11, pf12) = pf1\n        prval INTEQ () = fib_isfun2 (pf0, pf12)\n        prval pf_n_n = fibeq1 (pf0, pf0, pf1, pf1)\n        prval pf_1n_n1 = fibeq1 (pf11, pf1, pf0, pf2)\n        prval () = fib_isfun (pf_n_n, pf_1n_n1)\n        prval SGNind (pf31) = pf3\n        prval () = fibeq2 {n-1} (pf11, pf12, pf1, pf31) // IH\n      in\n        // nothing\n      end else let\n        prval FIBbas1 () = pf0\n        prval FIBbas2 () = pf1\n        prval FIBind (FIBbas1 (), FIBbas2 ()) = pf2\n        prval SGNbas () = pf3\n      in\n        // nothing\n      end // end of [sif]\n    // end of [fibeq2]\n    //\n    in\n      fibeq2 (pf0, pf1, pf2, pf3)\n    end // end of [fibeq2]","hashcode":"1RR3eWy4Nso","arch":"x86_64","filename":"foo","splat":[],"captures":["patsopt","typecheck"],"compiler":"patsopt","action":"typecheck"}